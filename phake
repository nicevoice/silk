#!/usr/bin/env php
<?php
use \silk\core\Application;
use \silk\cli\Cli;

//Find silk.api.php
//First look in lib dir
$api_file = '';
$rack_file = '';
if (file_exists(dirname(__FILE__) . '/lib/silk/silk.api.php'))
{
	$api_file = dirname(__FILE__) . '/lib/silk/silk.api.php';
	define('ROOT_DIR', dirname(__FILE__));
}
else if (file_exists(dirname(__FILE__) . '/silk.api.php')) //We're in the main dir
{
	$api_file = dirname(__FILE__) . '/silk.api.php';
	define('ROOT_DIR', dirname(__FILE__));
}
else //PEAR?
{
	if (include_once("PEAR/Config.php"))
	{
		$config = PEAR_Config::singleton('', '');
		$cmd = $config->get('php_dir');
		if ($cmd && !empty($cmd))
		{
			$potential_path = $cmd . '/silk/silk.api.php';
			if (file_exists($potential_path))
			{
				$api_file = $potential_path;
				$rack_dir = $cmd . '/silk/vendor/rack/lib';
			}

			if (isset($_SERVER['PWD']))
			{
				define('ROOT_DIR', $_SERVER['PWD']);
			}
			else
			{
				define('ROOT_DIR', dirname(__FILE__));
			}
		}
	}
}

if (!empty($api_file))
{
	include_once($api_file);
}
else
{
	fwrite(STDERR, "Can't find silk libraries.  Exiting.\n");
	exit(1);
}

Application::getInstance()->setup();

require dirname($api_file) . '/vendor/phake/lib/phake.php';
require dirname($api_file) . '/vendor/phake/lib/utils.php';
require dirname($api_file) . '/vendor/phake/lib/global_helpers.php';
require dirname($api_file) . '/vendor/phake/lib/option_parser.php';
require dirname($api_file) . '/vendor/phake/lib/builder.php';

phake\Builder::$global = new phake\Builder;

try {
    
    //
    // Defaults
    
	$action     = 'invoke';
    $task_names = array('default');
    $trace      = false;
    
    $args = $GLOBALS['argv'];
	array_shift($args);
	if (empty($args))
		$args = array('-T');
	$parser = new phake\OptionParser($args);
	foreach ($parser->get_options() as $option => $value) {
		switch ($option) {
			case 't':
			case 'trace':
				$trace = true;
				break;
			case 'T':
			case 'tasks':
				$action = 'list';
				break;
			default:
				throw new Exception("Unknown command line option '$option'");
		}
	}
	
	$cli_args = array();
	$cli_task_names = array();
	foreach ($parser->get_non_options() as $option) {
		if (strpos($option, '=') > 0) {
			list($k, $v) = explode('=', $option);
			$cli_args[$k] = $v;
		} else {
			$cli_task_names[] = $option;
		}
	}
	
	if (count($cli_task_names)) {
		$task_names = $cli_task_names;
	}
	
    //
    // Locate runfile
    
    $runfile = phake\resolve_runfile(getcwd());
    $directory = dirname($runfile);

	if (!@chdir($directory)) {
        throw new Exception("Couldn't change to directory '$directory'");
    } else {
        echo "(in $directory)\n";
    }

    phake\load_runfile($runfile, true, array(SILK_LIB_DIR));

    //
    // Go, go, go
    
    $application = phake\Builder::$global->get_application();
	$application->set_args($cli_args);
    $application->reset();
    
    switch ($action) {
        case 'list':
            $task_list = $application->get_task_list();
			if (count($task_list)) {
				$max = max(array_map('strlen', array_keys($task_list)));
				foreach ($task_list as $name => $desc) {
					echo str_pad($name, $max + 4) . $desc . "\n";
				}
			}
			break;
        case 'invoke':
            foreach ($task_names as $task_name) {
                $application->invoke($task_name);
            }
            break;
    }

} catch (phake\TaskNotFoundException $tnfe) {
    phake\fatal($tnfe, "Don't know how to build task '$task_name'\n");
} catch (Exception $e) {
    phake\fatal($e);
}
